#include <stdint.h>
#include <stdio.h>

#define IS_LETTER(a) ('a' <= a && a <= 'z') || ('A' <= a && a <= 'Z') // проверяем, является ли этот символ буквой


void forced_low_case(char *s, int n) { // принудительно все сиволы в строке приводит к нижнему регистру
    for (; n >= 4; n -= 4) { // пока в строке есть 4 байта, читаем их
        *((uint32_t *)s) |= 0b00100000001000000010000000100000; // представляем часть строки как безнаковую 32 битную переменную и заменяем каждый 6 бит символа на 1 через маску
        s += 4; // смещаем указатель на 4 байта
    }
    for (; n > 0; n--) { // если же строка оказалась на кратной 4 байтам, то оставшиеся символы дочитываем по одному
        (*s) |= 0b00100000; // ставим через маску 6 бит в позицию 1
        s++; // смещаем указатель
    }
}

void low_case(char *s) { // приводит в нижний регистор, проверяя что символ - буква
    int n = 0; // количество букв вподрят
    for (; (*s) != '\0'; s++) { // бежим посимвольно
        if (IS_LETTER(*s)) {
            n++; // увеличиваем счётчик в случае если это буква
        } else { // иначе
            forced_low_case(s - n, n); // отправляем подстроку в forced_low_case, описанную выше
            n = 0; // обнуляем счётчик букв, идущих вподряд
        }
    }
    forced_low_case(s, n); // отправляем оставшиюся часть строки в forced_low_case
}

/*
 *  Ниже указанные функции аналогичны, только переводят в верхний регистр
 */
void forced_upper_case(char *s, int n) {
    for (; n >= 4; n -= 4) {
        *((uint32_t *)s) &= 0b11011111110111111101111111011111;
        s += 4;
    }
    for (; n > 0; n--) {
        (*s) &= 0b11011111;
        s++;
    }
}

void upper_case(char *s) {
    int n = 0;
    for (; (*s) != '\0'; s++) {
        if (IS_LETTER(*s)) {
            n++;
        } else {
            forced_upper_case(s - n, n);
            n = 0;
        }
    }
    forced_upper_case(s - n, n);
}

int main() {
    char s[] = "AAAA01A-AAAAA, assDscd, asdscdf.";
    low_case(s);
    printf(s);
}