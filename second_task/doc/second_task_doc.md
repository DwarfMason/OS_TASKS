# Лабораторная работа №2. Управление процессами

```sh

second_task/src/<nubmer of the subtask>.c #Исходник

make second_task/src/cmake-build-debug/ #Компиляция исходников

second_task/src/cmake-build-debug/ #Путь до исполняемых файлов

```

#### Подзадание 1: 

>В основной программе переменной x присвоить значение 100, а затем вызвать fork(). Каково значение x в порождённом процессе?



В порожденном процессе значение переменной *x* останется равным *100*, т.к дочерний процесс буквально копирует саму программу и принаждежащую ей память, а следовательно и значения переменных.



>Что происходит, когда основной и порожденный процессы меняют значение x?



Как уже было сказано ранее, в момент вызова fork() выделяется дочерний процесс, который целиком копирует данный, следовательно при изменении значения *x*, что в дочернем, что в основном процессе, изменённое значение *x* останется только в этом самом процессе.

#### Подзадание 2:

>Порожденный процесс, созданный с помощью fork(), должен напечатать “hello”; основной  -  “goodbye”. Нужно обеспечить, чтобы порожденный процесс печатал первым без использования wait() в основном.

Для выполнения данного задания достаточно узнать, как подавать сигналы процессам. Например для выполнения данной задачи мы используем *raise()* для подачи сигнала, что родительский процесс должен быть приостановлен и после завершения дочернего процесса передаем сигнал на продолжение работы процесса.

#### Подзадание 3

>Для чего предусмотрено столько много вариантов exec()?

- Если в вариации exec имеется *P*, то ищет процесс-потомок в каталогах, заданных командой PATH.
- Если в exec имеется суффикс *l*, то аргументы передающиеся потомку передаются индивидуально, а не массивом.
- Если имеется суффикс *v*, то аргумент передаются массивом.
- Суффикс е указывает, что процессу-потомку будет передана одна или более строк окружения. Параметр envp(Обычно последний) представляет собой массив указателей на строки. Каждая строка, на которую ука­зывает массив, должна иметь следующий вид: переменная_окружения = значение.


#### Подзадание 4

> Что возвращает wait()?

Функция *wait()* возвращает -1 в случае ошибки, 0, если явно указано вернуть управление до завершения дочерних процессов, иначе идентификатор дочернего процесса, который завершил выполнение.

> Что произойдет, если использовать wait() в порожденном процессе?

Будет работать также. Если не имеется дочерних процессов у дочернего процесса, то вернет -1. Вызов в fork() стандартный: parent_process -> child_process.

> Когда использование waitpid() целесообразно?

*waitpid(pid_t pid, int *status, int options)* не ожидает завершения всех дочрених процессов, а лишь того, на который указывает *pid*.

Параметр pid может принимать несколько значений:

       < -1   означает, что нужно ждать  любого  дочернего  процесса,  чей  идентификатор  группы

              процессов равен абсолютному значению pid.



       -1     означает ожидать любого дочернего процесса; функция wait ведет себя точно так же.



       0      означает  ожидать  любого  дочернего  процесса,  чей идентификатор группы процессов

              равен таковому у текущего процесса.



       > 0    означает ожидать дочернего процесса, чем идентификатор равен pid.

Использование *status* в качестве входного параметра подробно изложено в исходном файле 4.c.
